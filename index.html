<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>심플 마인드맵 -v11</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        
        body {
            font-family: 'Malgun Gothic', sans-serif;
            background-color: #fdfdfd;
            overflow: hidden;
            height: 100vh;
        }

        #mindmap-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: auto;
        }

        #mindmap-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 3000px;
            height: 3000px;
            pointer-events: none;
        }

        #mindmap-svg path {
            stroke: #979797;
            stroke-width: 2;
            fill: none;
        }

        .node {
            position: absolute;
            background-color: #f0f0f0;
            border: 1px solid #adadad;
            border-radius: 25px;
            padding: 12px 20px;
            cursor: move;
            box-shadow: 0 4px 8px rgba(0,0,0,0.08);
            min-width: 80px;
            max-width: 400px;
            text-align: center;
            white-space: pre-wrap;
            word-wrap: break-word;
            word-break: keep-all;
            z-index: 10;
            user-select: none;
            writing-mode: horizontal-tb;
            display: inline-block;
        }

        .node.dragging {
            opacity: 0.7;
            box-shadow: 0 8px 16px rgba(0,0,0,0.3);
            z-index: 100;
        }

        .node.root {
            background-color: #4a90e2;
            color: white;
            border-color: #357ABD;
            font-weight: bold;
        }

        .node.selected {
            border-color: #d0021b;
            box-shadow: 0 0 15px rgba(208,2,27,0.5);
        }

        .node input {
            border: none;
            outline: none;
            background-color: transparent;
            text-align: center;
            font-size: 1em;
            width: 100%;
            color: inherit;
            font-family: 'Malgun Gothic', sans-serif;
        }

        .ui-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .ui-button {
            background-color: #fff;
            padding: 10px 16px;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .ui-button:hover {
            background-color: #f5f5f5;
        }

        #export-btn {
            background-color: #4CAF50;
            color: white;
            border: none;
        }

        #export-btn:hover {
            background-color: #45a049;
        }

        #center-btn {
            position: fixed;
            top: 20px;
            left: 20px;
            z-index: 1000;
        }

        #help-box {
            position: fixed;
            top: 80px;
            left: 20px;
            background-color: rgba(255,255,255,0.95);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            font-size: 13px;
            z-index: 1000;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #help-box strong {
            display: block;
            margin-bottom: 10px;
            font-size: 15px;
        }

        #help-box div {
            margin: 5px 0;
        }

        #help-box span {
            display: inline-block;
            background-color: #e9e9e9;
            padding: 2px 8px;
            border-radius: 4px;
            margin-right: 8px;
            font-family: Consolas, monospace;
        }
    </style>
</head>
<body>
    <div id="mindmap-container">
        <svg id="mindmap-svg"></svg>
    </div>

    <div class="ui-controls">
        <button id="save-map-btn" class="ui-button">맵 저장</button>
        <button id="load-map-btn" class="ui-button">맵 불러오기</button>
        <button id="export-btn" class="ui-button">이미지로 저장</button>
    </div>

    <button id="center-btn" class="ui-button">중앙으로</button>

    <div id="help-box">
        <strong>사용법</strong>
        <div><span>Tab</span>: 하위 가지</div>
        <div><span>Enter</span>: 동일선상 가지</div>
        <div><span>방향키</span>: 노드 선택 이동</div>
        <div><span>Del / Bksp</span>: 선택 노드 삭제</div>
        <div><span>드래그</span>: 노드 위치 이동</div>
        <div><span>더블클릭</span>: 텍스트 수정</div>
        <p style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ddd; font-size: 11px;">
            문의: sblab@secondbrainlab.com
        </p>
    </div>

    <input type="file" id="file-input" accept=".smm,.json" style="display: none;">

    <script>
        const container = document.getElementById('mindmap-container');
        const svg = document.getElementById('mindmap-svg');

        let nodes = [];
        let selectedNodeId = null;
        let nodeIdCounter = 0;
        const HORIZONTAL_GAP = 150;
        const VERTICAL_GAP = 30;

        let isDragging = false;
        let dragNode = null;
        let dragOffsetX = 0;
        let dragOffsetY = 0;

        function createNode(text, parentId = null) {
            const id = `node-${nodeIdCounter++}`;
            const div = document.createElement('div');
            div.id = id;
            div.className = 'node';
            div.textContent = text;
            
            if (!parentId) div.classList.add('root');
            
            container.appendChild(div);

            const nodeData = {
                id: id,
                text: text,
                parentId: parentId,
                children: [],
                element: div,
                x: 0,
                y: 0,
                direction: 1
            };

            nodes.push(nodeData);

            if (parentId) {
                const parent = findNode(parentId);
                if (parent) {
                    parent.children.push(id);
                    nodeData.direction = parent.direction;
                }
            }

            setupNodeEvents(div);
            return nodeData;
        }

        function findNode(id) {
            return nodes.find(n => n.id === id);
        }

        function findParent(childId) {
            const child = findNode(childId);
            return child && child.parentId ? findNode(child.parentId) : null;
        }

        function setupNodeEvents(element) {
            element.addEventListener('mousedown', (e) => {
                if (e.target.tagName === 'INPUT') return;
                
                isDragging = true;
                dragNode = findNode(element.id);
                
                const rect = element.getBoundingClientRect();
                dragOffsetX = e.clientX - rect.left;
                dragOffsetY = e.clientY - rect.top;
                
                element.classList.add('dragging');
                e.preventDefault();
            });

            element.addEventListener('click', (e) => {
                if (!isDragging) {
                    selectNode(element.id);
                }
            });

            element.addEventListener('dblclick', (e) => {
                e.stopPropagation();
                editNode(element.id);
            });
        }

        document.addEventListener('mousemove', (e) => {
            if (!isDragging || !dragNode) return;

            const rect = container.getBoundingClientRect();
            const x = e.clientX - rect.left - dragOffsetX + container.scrollLeft;
            const y = e.clientY - rect.top - dragOffsetY + container.scrollTop;

            dragNode.x = x + dragNode.element.offsetWidth / 2;
            dragNode.y = y + dragNode.element.offsetHeight / 2;

            dragNode.element.style.left = x + 'px';
            dragNode.element.style.top = y + 'px';

            updateLines();
        });

        document.addEventListener('mouseup', () => {
            if (isDragging && dragNode) {
                dragNode.element.classList.remove('dragging');
                isDragging = false;
                dragNode = null;
            }
        });

        function selectNode(id) {
            if (selectedNodeId) {
                const prev = findNode(selectedNodeId);
                if (prev) prev.element.classList.remove('selected');
            }
            
            const node = findNode(id);
            if (node) {
                node.element.classList.add('selected');
                selectedNodeId = id;
            }
        }

        function editNode(id) {
            const node = findNode(id);
            if (!node) return;

            const input = document.createElement('input');
            input.value = node.text;
            
            if (node.element.classList.contains('root')) {
                input.style.color = 'white';
            }

            node.element.textContent = '';
            node.element.appendChild(input);
            input.focus();
            input.select();

            const finish = () => {
                node.text = input.value.trim() || '새 노드';
                node.element.textContent = node.text;
                layout();
            };

            input.addEventListener('blur', finish);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    finish();
                }
            });
        }

        function deleteNode(id) {
            const node = findNode(id);
            if (!node) return;

            node.children.forEach(childId => deleteNode(childId));

            const parent = findParent(id);
            if (parent) {
                parent.children = parent.children.filter(cid => cid !== id);
            }

            node.element.remove();
            nodes = nodes.filter(n => n.id !== id);
        }

        function layout() {
            const root = nodes.find(n => !n.parentId);
            if (!root) return;

            const centerX = 1500;
            const centerY = 1500;

            root.x = centerX;
            root.y = centerY;
            root.element.style.left = (centerX - root.element.offsetWidth / 2) + 'px';
            root.element.style.top = (centerY - root.element.offsetHeight / 2) + 'px';

            const left = root.children.map(findNode).filter(n => n && n.direction === -1);
            const right = root.children.map(findNode).filter(n => n && n.direction === 1);

            let yR = centerY - getTotalHeight(right) / 2;
            right.forEach(child => {
                const h = getSubtreeHeight(child.id);
                positionSubtree(child.id, centerX, yR + h / 2);
                yR += h;
            });

            let yL = centerY - getTotalHeight(left) / 2;
            left.forEach(child => {
                const h = getSubtreeHeight(child.id);
                positionSubtree(child.id, centerX, yL + h / 2);
                yL += h;
            });

            updateLines();
        }

        function positionSubtree(id, parentX, centerY) {
            const node = findNode(id);
            if (!node) return;

            const parent = findParent(id);
            if (!parent) return;

            const x = parentX + node.direction * (parent.element.offsetWidth / 2 + HORIZONTAL_GAP);
            node.x = x;
            node.y = centerY;

            node.element.style.left = (x - node.element.offsetWidth / 2) + 'px';
            node.element.style.top = (centerY - node.element.offsetHeight / 2) + 'px';

            const children = node.children.map(findNode).filter(n => n);
            if (children.length === 0) return;

            const totalH = getTotalHeight(children);
            let currentY = centerY - totalH / 2;

            children.forEach(child => {
                const h = getSubtreeHeight(child.id);
                positionSubtree(child.id, x, currentY + h / 2);
                currentY += h;
            });
        }

        function getTotalHeight(nodeArray) {
            return nodeArray.reduce((sum, node) => sum + getSubtreeHeight(node.id), 0);
        }

        function getSubtreeHeight(id) {
            const node = findNode(id);
            if (!node) return 0;

            if (node.children.length === 0) {
                return node.element.offsetHeight + VERTICAL_GAP;
            }

            return node.children.reduce((sum, childId) => sum + getSubtreeHeight(childId), 0);
        }

        function updateLines() {
            svg.innerHTML = '';
            
            nodes.forEach(node => {
                if (!node.parentId) return;
                
                const parent = findNode(node.parentId);
                if (!parent) return;

                const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                const dir = node.direction;
                
                const x1 = parent.x + dir * parent.element.offsetWidth / 2;
                const y1 = parent.y;
                const x2 = node.x - dir * node.element.offsetWidth / 2;
                const y2 = node.y;
                
                const cx1 = x1 + dir * HORIZONTAL_GAP / 2;
                const cy1 = y1;
                const cx2 = x2 - dir * HORIZONTAL_GAP / 2;
                const cy2 = y2;
                
                path.setAttribute('d', `M ${x1},${y1} C ${cx1},${cy1} ${cx2},${cy2} ${x2},${y2}`);
                svg.appendChild(path);
            });
        }

        function balanceChildren() {
            const root = nodes.find(n => !n.parentId);
            if (!root) return;
            
            root.children.forEach((childId, i) => {
                const child = findNode(childId);
                if (child) {
                    child.direction = i % 2 === 0 ? 1 : -1;
                }
            });
        }

        // 키보드 단축키
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || !selectedNodeId) return;
            
            const selected = findNode(selectedNodeId);
            if (!selected) return;

            if (e.key === 'Tab') {
                e.preventDefault();
                const newNode = createNode('새 노드', selectedNodeId);
                if (!selected.parentId) balanceChildren();
                layout();
                selectNode(newNode.id);
                editNode(newNode.id);
            } else if (e.key === 'Enter') {
                e.preventDefault();
                if (selected.parentId) {
                    const parent = findParent(selectedNodeId);
                    const newNode = createNode('새 노드', parent.id);
                    if (!parent.parentId) balanceChildren();
                    layout();
                    selectNode(newNode.id);
                    editNode(newNode.id);
                }
            } else if (e.key === 'Delete' || e.key === 'Backspace') {
                e.preventDefault();
                if (selected.parentId) {
                    const parent = findParent(selectedNodeId);
                    deleteNode(selectedNodeId);
                    selectedNodeId = null;
                    layout();
                    if (parent) selectNode(parent.id);
                }
            }
        });

        // UI 버튼들
        document.getElementById('center-btn').addEventListener('click', () => {
            const root = nodes.find(n => !n.parentId);
            if (root) {
                container.scrollLeft = root.x - container.clientWidth / 2;
                container.scrollTop = root.y - container.clientHeight / 2;
                selectNode(root.id);
            }
        });

        document.getElementById('save-map-btn').addEventListener('click', () => {
            const data = {
                nodes: nodes.map(n => ({
                    id: n.id,
                    text: n.text,
                    parentId: n.parentId,
                    children: n.children,
                    x: n.x,
                    y: n.y,
                    direction: n.direction
                })),
                nodeIdCounter: nodeIdCounter
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'mindmap.smm';
            a.click();
        });

        document.getElementById('load-map-btn').addEventListener('click', () => {
            document.getElementById('file-input').click();
        });

        document.getElementById('file-input').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (ev) => {
                try {
                    const data = JSON.parse(ev.target.result);
                    
                    nodes.forEach(n => n.element.remove());
                    nodes = [];
                    svg.innerHTML = '';
                    nodeIdCounter = data.nodeIdCounter || 0;

                    data.nodes.forEach(nodeData => {
                        const node = createNode(nodeData.text, nodeData.parentId);
                        node.x = nodeData.x;
                        node.y = nodeData.y;
                        node.direction = nodeData.direction;
                        node.children = nodeData.children;
                        
                        node.element.style.left = (node.x - node.element.offsetWidth / 2) + 'px';
                        node.element.style.top = (node.y - node.element.offsetHeight / 2) + 'px';
                    });

                    updateLines();
                    const root = nodes.find(n => !n.parentId);
                    if (root) selectNode(root.id);
                } catch (err) {
                    alert('파일 로드 실패');
                }
            };
            reader.readAsText(file);
        });

        document.getElementById('export-btn').addEventListener('click', () => {
            const selected = document.querySelector('.node.selected');
            if (selected) selected.classList.remove('selected');

            html2canvas(container, {
                backgroundColor: '#fdfdfd',
                scale: 2
            }).then(canvas => {
                const url = canvas.toDataURL('image/png');
                const a = document.createElement('a');
                a.href = url;
                a.download = 'mindmap.png';
                a.click();
                
                if (selected) selected.classList.add('selected');
            });
        });

        // 초기화
        function init() {
            createNode('중심 토픽');
            layout();
            
            const root = nodes[0];
            if (root) {
                setTimeout(() => {
                    container.scrollLeft = root.x - container.clientWidth / 2;
                    container.scrollTop = root.y - container.clientHeight / 2;
                    selectNode(root.id);
                }, 100);
            }
        }

        init();
    </script>
</body>
</html>
