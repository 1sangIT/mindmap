<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>심플 마인드맵 v6</title>
    <!-- PWA 테마 색상 및 아이콘 설정 -->
    <meta name="theme-color" content="#4a90e2"/>
    <link rel="apple-touch-icon" href="https://placehold.co/192x192/4a90e2/ffffff?text=SMM">
    <!-- manifest.json 링크 (스크립트로 동적 생성) -->
    <link rel="manifest" id="manifest">
    
    <!-- html2canvas 라이브러리 로드 -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <style>
        /* 기본 페이지 스타일 */
        body {
            font-family: 'Malgun Gothic', '맑은 고딕', sans-serif;
            background-color: #fdfdfd;
            color: #333;
            margin: 0;
            padding: 0;
            overflow: hidden; /* 스크롤바 제거 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
        }

        /* 마인드맵 전체를 감싸는 컨테이너 */
        #mindmap-container {
            position: relative;
            width: 100%;
            height: 100%;
            overflow: auto; /* 내용이 많아지면 스크롤 가능하도록 변경 */
        }
        
        /* 스크롤바 디자인 (선택 사항) */
        #mindmap-container::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        #mindmap-container::-webkit-scrollbar-thumb {
            background-color: #ccc;
            border-radius: 4px;
        }
        #mindmap-container::-webkit-scrollbar-track {
            background-color: #f0f0f0;
        }

        /* 노드 기본 스타일 */
        .node {
            position: absolute;
            background-color: #f0f0f0;
            border: 1px solid #adadad;
            border-radius: 25px;
            padding: 12px 20px;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
            min-width: 50px;
            text-align: center;
            white-space: nowrap;
            z-index: 1;
            user-select: none; /* 드래그 시 텍스트 선택 방지 */
        }

        .node.root {
            background-color: #4a90e2;
            color: white;
            border-color: #357ABD;
        }

        .node.selected {
            border-color: #d0021b;
            box-shadow: 0 0 15px rgba(208, 2, 27, 0.5);
            transform: scale(1.05);
        }

        .node input {
            border: none;
            outline: none;
            background-color: transparent;
            text-align: center;
            font-size: 1em;
            width: 100%;
            padding: 0;
            margin: 0;
            color: inherit;
        }

        #mindmap-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 300%; /* 맵 확장 공간 확보 */
            height: 300%;
            pointer-events: none;
        }
        
        #mindmap-svg path {
            stroke: #979797;
            stroke-width: 2;
            fill: none;
        }
        
        .ui-controls {
            position: fixed;
            top: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 10;
        }

        .ui-button {
            background-color: #fff;
            color: #333;
            padding: 8px 16px;
            border: 1px solid #ccc;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            transition: all 0.2s;
        }
        .ui-button:hover {
            background-color: #f5f5f5;
            border-color: #aaa;
        }
        #export-btn {
            background-color: #4CAF50;
            color: white;
            border-color: #4CAF50;
        }
        #export-btn:hover {
            background-color: #45a049;
            border-color: #45a049;
        }
        
        #center-btn {
            position: fixed;
            top: 20px;
            left: 20px;
        }

        #watermark {
            position: fixed;
            bottom: 15px;
            right: 20px;
            font-size: 12px;
            color: #cccccc;
            z-index: 10;
            pointer-events: none;
        }
        
        #help-box {
            position: fixed;
            top: 65px;
            left: 20px;
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 10;
            font-size: 14px;
            color: #555;
            pointer-events: none;
        }
        #help-box strong {
            display: block;
            margin-bottom: 10px;
            font-size: 16px;
            color: #333;
        }
        #help-box ul { list-style: none; padding: 0; margin: 0; }
        #help-box li { margin-bottom: 8px; }
        #help-box li:last-child { margin-bottom: 0; }
        #help-box span {
            display: inline-block;
            background-color: #e9e9e9;
            border-radius: 4px;
            padding: 2px 6px;
            margin-right: 8px;
            font-family: 'Consolas', monospace;
            border: 1px solid #dcdcdc;
            color: #333;
        }
        
        /* 모바일 반응형 스타일 */
        @media (max-width: 768px) {
            .ui-button {
                padding: 10px;
                font-size: 12px;
            }
            .ui-controls {
                top: 10px;
                right: 10px;
            }
            #center-btn {
                top: 10px;
                left: 10px;
            }
            #help-box {
                top: 55px;
                left: 10px;
                padding: 10px;
                font-size: 12px;
            }
             #help-box strong { font-size: 14px; }
        }

    </style>
</head>
<body>

    <div id="mindmap-container">
        <svg id="mindmap-svg"></svg>
    </div>
    
    <div class="ui-controls">
        <button id="save-map-btn" class="ui-button">맵 저장</button>
        <button id="load-map-btn" class="ui-button">맵 불러오기</button>
        <button id="export-btn" class="ui-button">이미지로 저장</button>
    </div>
    
    <input type="file" id="file-input" accept=".smm, .json" style="display: none;">

    <button id="center-btn" class="ui-button">중앙으로</button>
    
    <div id="watermark">sblab@secondbrainlab.com</div>
    
    <div id="help-box">
        <strong>사용법</strong>
        <ul>
            <li><span>Tab</span>: 하위 가지</li>
            <li><span>Enter</span>: 동일선상 가지</li>
            <li><span>방향키</span>: 노드 선택 이동</li>
            <li><span>Del / Bksp</span>: 선택 노드 삭제</li>
            <li><span>Ctrl + X</span>: 잘라내기</li>
            <li><span>Ctrl + V</span>: 붙여넣기</li>
            <li><span>더블클릭/길게누르기</span>: 수정</li>
        </ul>
    </div>


    <script>
        // --- PWA 설정 ---
        function setupPWA() {
            // 1. Manifest 파일 동적 생성
            const manifestData = {
                "name": "심플 마인드맵",
                "short_name": "마인드맵",
                "start_url": ".",
                "display": "standalone",
                "background_color": "#fdfdfd",
                "theme_color": "#4a90e2",
                "description": "간단하고 빠른 웹 기반 마인드맵 애플리케이션",
                "icons": [
                    { "src": "https://placehold.co/192x192/4a90e2/ffffff?text=SMM", "sizes": "192x192", "type": "image/png" },
                    { "src": "https://placehold.co/512x512/4a90e2/ffffff?text=SMM", "sizes": "512x512", "type": "image/png" }
                ]
            };
            const manifestString = JSON.stringify(manifestData);
            const manifestBlob = new Blob([manifestString], { type: 'application/json' });
            const manifestUrl = URL.createObjectURL(manifestBlob);
            document.getElementById('manifest').href = manifestUrl;

            // 2. Service Worker 등록
            if ('serviceWorker' in navigator) {
                const swCode = `
                    const CACHE_NAME = 'simple-mindmap-cache-v1';
                    const urlsToCache = [
                        '/',
                        '/index.html', // 만약 파일 이름이 다르다면 이 부분을 수정해야 합니다.
                        'https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js'
                    ];
                    self.addEventListener('install', event => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then(cache => cache.addAll(urlsToCache))
                        );
                    });
                    self.addEventListener('fetch', event => {
                        event.respondWith(
                            caches.match(event.request)
                                .then(response => {
                                    return response || fetch(event.request);
                                })
                        );
                    });
                `;
                const swBlob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(swBlob);
                navigator.serviceWorker.register(swUrl)
                    .then(registration => console.log('Service Worker 등록 성공:', registration))
                    .catch(error => console.log('Service Worker 등록 실패:', error));
            }
        }
        setupPWA();

        // --- 마인드맵 애플리케이션 코드 (이전과 동일) ---
        const container = document.getElementById('mindmap-container');
        const svg = document.getElementById('mindmap-svg');
        const exportBtn = document.getElementById('export-btn');
        const centerBtn = document.getElementById('center-btn');
        const watermark = document.getElementById('watermark');
        const helpBox = document.getElementById('help-box');
        const saveMapBtn = document.getElementById('save-map-btn');
        const loadMapBtn = document.getElementById('load-map-btn');
        const fileInput = document.getElementById('file-input');

        let nodes = [];
        let selectedNodeId = null;
        let clipboardNodeData = null; 
        let nodeIdCounter = 0; 
        const HORIZONTAL_GAP = 120;
        const VERTICAL_GAP = 20;

        function generateId() { return `node-${nodeIdCounter++}`; }
        function findNodeById(id) { return nodes.find(n => n.id === id) || null; }
        function findParent(childId) {
            const childNode = findNodeById(childId);
            return childNode ? findNodeById(childNode.parentId) : null;
        }

        function createNode(text, parentId = null, loadedId = null) {
            const id = loadedId || generateId();
            if (loadedId) {
                const numericId = parseInt(loadedId.split('-')[1]);
                if (numericId >= nodeIdCounter) nodeIdCounter = numericId + 1;
            }
            const nodeElement = document.createElement('div');
            nodeElement.id = id;
            nodeElement.className = 'node';
            nodeElement.innerHTML = `<span>${text}</span>`;
            if (!parentId) nodeElement.classList.add('root');
            container.appendChild(nodeElement);
            const nodeData = { id, text, parentId, children: [], element: nodeElement, x: 0, y: 0, direction: 1 };
            nodes.push(nodeData);
            if (parentId) {
                const parentNode = findNodeById(parentId);
                if (parentNode) {
                    parentNode.children.push(id);
                    nodeData.direction = parentNode.direction;
                }
            }
            addNodeEventListeners(nodeElement);
            return nodeData;
        }

        function addNodeEventListeners(nodeElement) {
            nodeElement.addEventListener('dblclick', (e) => { e.stopPropagation(); editNodeText(nodeElement.id); });
            let longPressTimer;
            nodeElement.addEventListener('touchstart', (e) => {
                if (e.touches.length > 1) return;
                longPressTimer = setTimeout(() => { e.preventDefault(); editNodeText(nodeElement.id); }, 500);
            }, { passive: false });
            nodeElement.addEventListener('touchend', () => clearTimeout(longPressTimer));
            nodeElement.addEventListener('touchmove', () => clearTimeout(longPressTimer));
            nodeElement.addEventListener('click', (e) => { e.stopPropagation(); selectNode(nodeElement.id); });
            nodeElement.setAttribute('draggable', true);
            nodeElement.addEventListener('dragstart', (e) => {
                e.stopPropagation();
                if(findNodeById(nodeElement.id)?.parentId) e.dataTransfer.setData('text/plain', nodeElement.id);
                else e.preventDefault();
            });
            nodeElement.addEventListener('dragover', (e) => { e.preventDefault(); e.stopPropagation(); });
            nodeElement.addEventListener('drop', (e) => {
                e.preventDefault(); e.stopPropagation();
                const draggedNodeId = e.dataTransfer.getData('text/plain');
                const targetNodeId = nodeElement.id;
                if (draggedNodeId && draggedNodeId !== targetNodeId && !isAncestor(draggedNodeId, targetNodeId)) {
                    moveNode(draggedNodeId, targetNodeId);
                }
            });
        }
        
        function selectNode(id) {
            if (selectedNodeId) findNodeById(selectedNodeId)?.element.classList.remove('selected');
            const newSelectedNode = findNodeById(id);
            if(newSelectedNode) {
                newSelectedNode.element.classList.add('selected');
                selectedNodeId = id;
                newSelectedNode.element.scrollIntoView({ behavior: 'smooth', block: 'center', inline: 'center' });
            }
        }
        
        function deselectAll() {
             if (selectedNodeId) {
                findNodeById(selectedNodeId)?.element.classList.remove('selected');
                selectedNodeId = null;
            }
        }

        function editNodeText(id) {
            const node = findNodeById(id);
            if (!node) return;
            const span = node.element.querySelector('span');
            const input = document.createElement('input');
            input.type = 'text';
            input.value = node.text;
            if (node.element.classList.contains('root')) input.style.color = 'white';
            node.element.replaceChild(input, span);
            input.focus(); input.select();
            const finishEditing = () => {
                const newText = input.value.trim() || '새 노드';
                if (node.element.contains(input)) {
                    node.text = newText;
                    const newSpan = document.createElement('span');
                    newSpan.textContent = node.text;
                    node.element.replaceChild(newSpan, input);
                    reorganizeLayout(); 
                }
            };
            input.addEventListener('blur', finishEditing);
            input.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') { e.stopPropagation(); finishEditing(); }
                else if (e.key === 'Escape') { if (node.element.contains(input)) node.element.replaceChild(span, input); }
            });
        }
        
        function deleteNode(nodeId) {
            const nodeToDelete = findNodeById(nodeId);
            if (!nodeToDelete) return;
            [...nodeToDelete.children].forEach(childId => deleteNode(childId));
            const parent = findParent(nodeId);
            if (parent) parent.children = parent.children.filter(id => id !== nodeId);
            nodeToDelete.element.remove();
            nodes = nodes.filter(n => n.id !== nodeId);
        }

        function moveNode(nodeId, newParentId) {
            const nodeToMove = findNodeById(nodeId);
            const newParent = findNodeById(newParentId);
            if (!nodeToMove || !newParent) return;
            const oldParent = findParent(nodeId);
            if (oldParent) oldParent.children = oldParent.children.filter(id => id !== nodeId);
            nodeToMove.parentId = newParentId;
            newParent.children.push(nodeId);
            if (newParent.parentId === null) balanceRootChildren();
            else nodeToMove.direction = newParent.direction;
            reorganizeLayout();
        }

        function isAncestor(potentialAncestorId, childId) {
            const childNode = findNodeById(childId);
            if (!childNode || !childNode.parentId) return false;
            if (childNode.parentId === potentialAncestorId) return true;
            return isAncestor(potentialAncestorId, childNode.parentId);
        }

        function reorganizeLayout() {
            const root = nodes.find(n => !n.parentId);
            if (!root) return;
            const containerCenterX = container.scrollWidth / 2;
            const containerCenterY = container.clientHeight / 2;
            root.x = containerCenterX; root.y = containerCenterY;
            root.element.style.left = `${root.x - root.element.offsetWidth / 2}px`;
            root.element.style.top = `${root.y - root.element.offsetHeight / 2}px`;
            const leftChildren = root.children.map(findNodeById).filter(n => n.direction === -1);
            const rightChildren = root.children.map(findNodeById).filter(n => n.direction === 1);
            const rightTreeHeight = calculateTotalSubtreeHeight(rightChildren);
            let currentYRight = root.y - rightTreeHeight / 2;
            rightChildren.forEach(child => {
                const childSubtreeHeight = calculateSubtreeHeight(child.id);
                positionNodesRecursively(child.id, root.x, currentYRight + childSubtreeHeight / 2);
                currentYRight += childSubtreeHeight;
            });
            const leftTreeHeight = calculateTotalSubtreeHeight(leftChildren);
            let currentYLeft = root.y - leftTreeHeight / 2;
            leftChildren.forEach(child => {
                const childSubtreeHeight = calculateSubtreeHeight(child.id);
                positionNodesRecursively(child.id, root.x, currentYLeft + childSubtreeHeight / 2);
                currentYLeft += childSubtreeHeight;
            });
            updateLines();
        }

        function positionNodesRecursively(nodeId, parentX, y) {
            const node = findNodeById(nodeId);
            if (!node) return;
            const parent = findParent(nodeId);
            if(!parent) return;
            const direction = node.direction;
            const x = parentX + direction * (parent.element.offsetWidth / 2 + HORIZONTAL_GAP);
            const subtreeHeight = calculateSubtreeHeight(nodeId);
            node.x = x; node.y = y;
            node.element.style.left = `${x - node.element.offsetWidth / 2}px`;
            node.element.style.top = `${y - node.element.offsetHeight / 2}px`;
            const children = node.children.map(findNodeById);
            if (children.length === 0) return;
            let currentY = y - subtreeHeight / 2;
            children.forEach(child => {
                const childSubtreeHeight = calculateSubtreeHeight(child.id);
                positionNodesRecursively(child.id, node.x, currentY + childSubtreeHeight / 2);
                currentY += childSubtreeHeight;
            });
        }
        
        function calculateTotalSubtreeHeight(nodeArray) { return nodeArray.reduce((acc, node) => acc + calculateSubtreeHeight(node.id), 0); }
        function calculateSubtreeHeight(nodeId) {
            const node = findNodeById(nodeId);
            if (!node) return 0;
            if (node.children.length === 0) return node.element.offsetHeight + VERTICAL_GAP;
            return node.children.reduce((total, childId) => total + calculateSubtreeHeight(childId), 0);
        }

        function updateLines() {
            svg.innerHTML = '';
            nodes.forEach(node => {
                if (node.parentId) {
                    const parent = findNodeById(node.parentId);
                    if (parent) {
                        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                        const dir = node.direction;
                        const x1 = parent.x + dir * parent.element.offsetWidth / 2; const y1 = parent.y;
                        const x2 = node.x - dir * node.element.offsetWidth / 2; const y2 = node.y;
                        const controlX1 = x1 + dir * (HORIZONTAL_GAP / 2); const controlY1 = y1;
                        const controlX2 = x2 - dir * (HORIZONTAL_GAP / 2); const controlY2 = y2;
                        path.setAttribute('d', `M ${x1},${y1} C ${controlX1},${controlY1} ${controlX2},${controlY2} ${x2},${y2}`);
                        svg.appendChild(path);
                    }
                }
            });
        }

        function balanceRootChildren() {
            const root = nodes.find(n => !n.parentId);
            if (!root) return;
            root.children.map(findNodeById).forEach((child, index) => { child.direction = (index % 2 === 0) ? 1 : -1; });
        }
        
        document.addEventListener('keydown', (e) => {
            if (e.target.tagName === 'INPUT' || !selectedNodeId) return;
            const selectedNode = findNodeById(selectedNodeId);
            if (!selectedNode) return;
            const arrowKeys = ['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'];
            if (arrowKeys.includes(e.key)) {
                e.preventDefault();
                if (selectedNode.parentId === null) {
                    if (e.key === 'ArrowRight') {
                        const rightChildren = selectedNode.children.map(findNodeById).filter(n => n.direction === 1);
                        if (rightChildren.length > 0) selectNode(rightChildren[0].id);
                    } else if (e.key === 'ArrowLeft') {
                        const leftChildren = selectedNode.children.map(findNodeById).filter(n => n.direction === -1);
                        if (leftChildren.length > 0) selectNode(leftChildren[0].id);
                    }
                    return;
                }
                const parent = findParent(selectedNodeId);
                const siblingsInDirection = parent.children.map(findNodeById).filter(n => n.direction === selectedNode.direction).sort((a, b) => a.y - b.y);
                const currentIndex = siblingsInDirection.findIndex(n => n.id === selectedNodeId);
                switch (e.key) {
                    case 'ArrowUp': if (currentIndex > 0) selectNode(siblingsInDirection[currentIndex - 1].id); break;
                    case 'ArrowDown': if (currentIndex < siblingsInDirection.length - 1) selectNode(siblingsInDirection[currentIndex + 1].id); break;
                    case 'ArrowLeft':
                        if (selectedNode.direction === 1) selectNode(parent.id);
                        else if (selectedNode.children.length > 0) selectNode(selectedNode.children[0].id);
                        break;
                    case 'ArrowRight':
                        if (selectedNode.direction === -1) selectNode(parent.id);
                        else if (selectedNode.children.length > 0) selectNode(selectedNode.children[0].id);
                        break;
                }
                return;
            }
            switch (e.key) {
                case 'Delete': case 'Backspace':
                     e.preventDefault();
                     if (selectedNode.parentId) {
                        const parent = findParent(selectedNodeId); deleteNode(selectedNodeId); selectedNodeId = null;
                        reorganizeLayout(); if (parent) selectNode(parent.id);
                     } break;
                case 'Tab': e.preventDefault();
                    let newNodeTab;
                    if (selectedNode.parentId === null) { newNodeTab = createNode('새 노드', selectedNodeId); balanceRootChildren(); }
                    else { newNodeTab = createNode('새 노드', selectedNodeId); }
                    reorganizeLayout(); selectNode(newNodeTab.id); editNodeText(newNodeTab.id); break;
                case 'Enter': e.preventDefault();
                    if (selectedNode.parentId) {
                        const parent = findParent(selectedNodeId);
                        const newNodeEnter = createNode('새 노드', parent.id);
                        if (parent.parentId === null) balanceRootChildren();
                        reorganizeLayout(); selectNode(newNodeEnter.id); editNodeText(newNodeEnter.id);
                    } break;
            }
            if ((e.ctrlKey || e.metaKey) && selectedNode.parentId) {
                if (e.key === 'x') { clipboardNodeData = selectedNode.id; selectedNode.element.style.opacity = '0.3'; }
                else if (e.key === 'v' && clipboardNodeData) {
                    const nodeToPaste = findNodeById(clipboardNodeData);
                    if (nodeToPaste && selectedNodeId !== clipboardNodeData && !isAncestor(clipboardNodeData, selectedNodeId)) {
                        moveNode(clipboardNodeData, selectedNodeId); nodeToPaste.element.style.opacity = '1'; clipboardNodeData = null;
                    }
                }
            }
        });
        
        container.addEventListener('click', (e) => { if (e.target === container) deselectAll(); });
        centerBtn.addEventListener('click', () => { const root = nodes.find(n => !n.parentId); if (root) selectNode(root.id); });

        saveMapBtn.addEventListener('click', () => {
            const savableNodes = nodes.map(n => ({ id: n.id, text: n.text, parentId: n.parentId, children: n.children, direction: n.direction }));
            const data = { nodes: savableNodes, nodeIdCounter };
            const jsonString = JSON.stringify(data, null, 2);
            const blob = new Blob([jsonString], { type: 'application/json' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = 'mindmap.smm';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        });

        loadMapBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', (event) => {
            const file = event.target.files[0]; if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = JSON.parse(e.target.result);
                    if (data && data.nodes) rebuildMapFromData(data); else alert('잘못된 파일 형식입니다.');
                } catch (err) { alert('파일을 불러오는 중 오류가 발생했습니다.'); }
            };
            reader.readAsText(file); fileInput.value = '';
        });

        function rebuildMapFromData(data) {
            container.querySelectorAll('.node, #mindmap-svg > *').forEach(el => el.remove());
            nodes = []; selectedNodeId = null; nodeIdCounter = data.nodeIdCounter || 0;
            data.nodes.forEach(nodeData => {
                const { id, text, parentId } = nodeData;
                createNode(text, parentId, id);
            });
            balanceRootChildren();
            reorganizeLayout();
            const root = data.nodes.find(n => !n.parentId);
            if(root) selectNode(root.id);
        }

        exportBtn.addEventListener('click', () => {
            const selectedElem = document.querySelector('.node.selected');
            if (selectedElem) selectedElem.classList.remove('selected');
            watermark.style.display = 'none'; helpBox.style.display = 'none';
            const { scrollLeft, scrollTop } = container;
            container.scrollTo(0, 0);
            html2canvas(container, {
                backgroundColor: '#fdfdfd', scale: window.devicePixelRatio,
                width: container.scrollWidth, height: container.scrollHeight,
                windowWidth: container.scrollWidth, windowHeight: container.scrollHeight,
            }).then(canvas => {
                const link = document.createElement('a');
                link.href = canvas.toDataURL('image/png'); link.download = 'mindmap.png';
                link.click();
                if (selectedElem) selectedElem.classList.add('selected');
                watermark.style.display = 'block'; helpBox.style.display = 'block';
                container.scrollTo(scrollLeft, scrollTop);
            });
        });

        let isPanning = false; let lastPanX, lastPanY;
        container.addEventListener('touchstart', (e) => {
            if (e.target === container || e.target === svg) {
                isPanning = true; const touch = e.touches[0];
                lastPanX = touch.clientX; lastPanY = touch.clientY;
            }
        }, { passive: true });
        container.addEventListener('touchmove', (e) => {
            if (!isPanning || !e.touches[0]) return;
            const touch = e.touches[0];
            const dx = touch.clientX - lastPanX; const dy = touch.clientY - lastPanY;
            container.scrollLeft -= dx; container.scrollTop -= dy;
            lastPanX = touch.clientX; lastPanY = touch.clientY;
        }, { passive: true });
        container.addEventListener('touchend', () => { isPanning = false; });
        
        window.addEventListener('resize', reorganizeLayout);
        function init() {
            createNode('중심 토픽');
            reorganizeLayout();
            selectNode(nodes[0].id);
            container.scrollLeft = (container.scrollWidth - container.clientWidth) / 2;
        }
        window.onload = init;
    </script>
</body>
</html>
